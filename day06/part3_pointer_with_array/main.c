#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

int main() {
	// 포인터와 배열의 관계
	// 우리가 이전에 배웠던 배열은 내부적으로
	// 포인터 변수와 동일하게 동작한다.
	// 0번째 요소의 주소를 배열 변수가
	// 들고 있으므로 그 배열 변수는 포인터 변수와
	// 동일하게 취급할 수 있다.
	
	// 배열의 요소 접근법
	int arr[5] = { 1, 2, 3, 4, 5 };
	// 대괄호[] 안에 인덱스를 넣어서 접근을 했다.
	printf("%d\n", arr[2]); // 3

	// arr이라는 배열 변수에는 어떤 값이 들어있는 걸까?
	printf("arr:\t%p\n", arr); // 주소값
	// arr의 0번째 요소의 주소는 어떨까?
	int* ptrNum0 = &(arr[0]);
	printf("arr[0]:\t%p\n", ptrNum0);

	// 위 결과를 봤을 때, arr의 주소값과 arr[0]요소의
	// 주소값은 서로 같다는 것을 알 수 있다.
	// 즉, arr배열 변수는 0번째 요소를 기준으로
	// 다른 배열 요소에 접근한다는 의미이다.

	// 인덱스의 의미는 무엇인가?
	// 메모리 주소상에서 "몇 칸을 이동"했는가를 나타내는 숫자다.
	// arr 포인터 변수에 1을 더했다는 것은
	// 해당 메모리 주소에서 옆으로 한 칸 이동했음을 의미한다.
	// 해당 메모리 주소의 값에 접근하기 위해 *을 앞에 붙이고
	printf("*(arr + 1):\t%d\n",  *(arr + 1)); // 2
	// arr 변수에서 1번째 요소의 값을 접근한 것과
	// 동일한 결과를 보였다.

	// 만약 *(arr+1)이 arr[1]과 같은 저장공간을 가리킨다면
	// 그 값을 변경했을 때, 다른 한쪽에서도 같은 값에
	// 접근하게 될 것이다.
	*(arr + 1) = 21;

	printf("arr[1]:\t%d\n", arr[1]); // 21

	printf("%p\n%p\n", (arr + 1), &arr[1]);

	return 0;
}